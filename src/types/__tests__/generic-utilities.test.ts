/**
 * Generic Utility Functions and Type Transformation Tests
 * 
 * Tests generic functions, type utilities, advanced TypeScript features,
 * and complex type transformations with various type parameters.
 */

import {
  Module,
  User,
  Quiz,
  Question,
  UserProgress,
  Permission,
  UserRole,
  ResourceType,
  Action,
  AdaptiveLearningData,
  ConceptMastery,
  Achievement
} from '../index';

describe('Generic Utility Functions and Type Transformations', () => {
  describe('Generic Collection Utilities', () => {
    // Generic utility functions for testing
    function createCollection<T>(items: T[]): T[] {
      return [...items];
    }

    function findByProperty<T, K extends keyof T>(
      items: T[],
      property: K,
      value: T[K]
    ): T | undefined {
      return items.find(item => item[property] === value);
    }

    function filterByProperty<T, K extends keyof T>(
      items: T[],
      property: K,
      value: T[K]
    ): T[] {
      return items.filter(item => item[property] === value);
    }

    function mapProperty<T, K extends keyof T>(
      items: T[],
      property: K
    ): T[K][] {
      return items.map(item => item[property]);
    }

    function groupBy<T, K extends keyof T>(
      items: T[],
      property: K
    ): Map<T[K], T[]> {
      return items.reduce((map, item) => {
        const key = item[property];
        const group = map.get(key) || [];
        group.push(item);
        map.set(key, group);
        return map;
      }, new Map<T[K], T[]>());
    }

    it('should work with Module collections', () => {
      const modules: Module[] = [\n        {\n          id: 'module-1',\n          title: 'Introduction to Psychology',\n          description: 'Basic psychology concepts',\n          estimatedTime: 60,\n          difficulty: 'beginner'\n        },\n        {\n          id: 'module-2',\n          title: 'Advanced Psychology',\n          description: 'Advanced topics',\n          estimatedTime: 120,\n          difficulty: 'advanced'\n        },\n        {\n          id: 'module-3',\n          title: 'Intermediate Psychology',\n          description: 'Intermediate concepts',\n          estimatedTime: 90,\n          difficulty: 'intermediate'\n        }\n      ];\n\n      const moduleCollection = createCollection(modules);\n      expect(moduleCollection).toHaveLength(3);\n      expect(moduleCollection).not.toBe(modules); // Should be a new array\n\n      const foundModule = findByProperty(modules, 'difficulty', 'advanced');\n      expect(foundModule).toBeDefined();\n      expect(foundModule?.title).toBe('Advanced Psychology');\n\n      const beginnerModules = filterByProperty(modules, 'difficulty', 'beginner');\n      expect(beginnerModules).toHaveLength(1);\n      expect(beginnerModules[0].title).toBe('Introduction to Psychology');\n\n      const titles = mapProperty(modules, 'title');\n      expect(titles).toEqual([\n        'Introduction to Psychology',\n        'Advanced Psychology',\n        'Intermediate Psychology'\n      ]);\n\n      const groupedByDifficulty = groupBy(modules, 'difficulty');\n      expect(groupedByDifficulty.has('beginner')).toBe(true);\n      expect(groupedByDifficulty.get('advanced')).toHaveLength(1);\n    });\n\n    it('should work with User collections', () => {\n      const users: Partial<User>[] = [\n        {\n          id: 'user-1',\n          email: 'admin@example.com',\n          username: 'admin',\n          role: UserRole.ADMIN,\n          isActive: true\n        },\n        {\n          id: 'user-2',\n          email: 'instructor@example.com',\n          username: 'instructor',\n          role: UserRole.INSTRUCTOR,\n          isActive: true\n        },\n        {\n          id: 'user-3',\n          email: 'student@example.com',\n          username: 'student',\n          role: UserRole.STUDENT,\n          isActive: false\n        }\n      ];\n\n      const activeUsers = filterByProperty(users, 'isActive', true);\n      expect(activeUsers).toHaveLength(2);\n\n      const usernames = mapProperty(users, 'username');\n      expect(usernames).toEqual(['admin', 'instructor', 'student']);\n\n      const groupedByRole = groupBy(users, 'role');\n      expect(groupedByRole.has(UserRole.ADMIN)).toBe(true);\n      expect(groupedByRole.get(UserRole.STUDENT)).toHaveLength(1);\n    });\n\n    it('should handle complex property access', () => {\n      interface ComplexObject {\n        id: string;\n        metadata: {\n          created: Date;\n          tags: string[];\n          scores: Record<string, number>;\n        };\n        settings: {\n          enabled: boolean;\n          priority: number;\n        };\n      }\n\n      const complexObjects: ComplexObject[] = [\n        {\n          id: 'obj-1',\n          metadata: {\n            created: new Date('2024-01-01'),\n            tags: ['tag1', 'tag2'],\n            scores: { math: 85, science: 92 }\n          },\n          settings: { enabled: true, priority: 1 }\n        },\n        {\n          id: 'obj-2',\n          metadata: {\n            created: new Date('2024-02-01'),\n            tags: ['tag3'],\n            scores: { math: 78, science: 88 }\n          },\n          settings: { enabled: false, priority: 2 }\n        }\n      ];\n\n      const enabledObjects = filterByProperty(complexObjects, 'settings', {\n        enabled: true,\n        priority: 1\n      });\n      // Note: This will likely fail due to object reference comparison\n      // but demonstrates the generic constraint system\n      expect(enabledObjects).toHaveLength(0); // Objects don't match by reference\n\n      const ids = mapProperty(complexObjects, 'id');\n      expect(ids).toEqual(['obj-1', 'obj-2']);\n    });\n  });\n\n  describe('Generic Transformation Utilities', () => {\n    function transform<T, U>(item: T, transformer: (item: T) => U): U {\n      return transformer(item);\n    }\n\n    function batchTransform<T, U>(\n      items: T[],\n      transformer: (item: T, index: number) => U\n    ): U[] {\n      return items.map(transformer);\n    }\n\n    function conditionalTransform<T, U>(\n      item: T,\n      condition: (item: T) => boolean,\n      transformer: (item: T) => U,\n      fallback: U\n    ): U {\n      return condition(item) ? transformer(item) : fallback;\n    }\n\n    it('should transform Module to summary format', () => {\n      const module: Module = {\n        id: 'module-1',\n        title: 'Psychology Basics',\n        description: 'An introduction to psychology',\n        estimatedTime: 120,\n        difficulty: 'beginner',\n        category: 'psychology',\n        tags: ['psychology', 'basics', 'introduction']\n      };\n\n      interface ModuleSummary {\n        id: string;\n        title: string;\n        duration: string;\n        level: string;\n        topics: string[];\n      }\n\n      const summary = transform(module, (m): ModuleSummary => ({\n        id: m.id,\n        title: m.title,\n        duration: `${m.estimatedTime} minutes`,\n        level: m.difficulty,\n        topics: m.tags || []\n      }));\n\n      expect(summary.id).toBe('module-1');\n      expect(summary.duration).toBe('120 minutes');\n      expect(summary.level).toBe('beginner');\n      expect(summary.topics).toEqual(['psychology', 'basics', 'introduction']);\n    });\n\n    it('should batch transform quiz questions', () => {\n      const questions: Question[] = [\n        {\n          id: 'q1',\n          question: 'What is psychology?',\n          type: 'multiple-choice',\n          options: [\n            { id: 'a', text: 'Study of mind', isCorrect: true },\n            { id: 'b', text: 'Study of body', isCorrect: false }\n          ],\n          correctAnswer: 0,\n          explanation: 'Psychology is the study of mind and behavior'\n        },\n        {\n          id: 'q2',\n          question: 'True or False: Jung founded analytical psychology',\n          type: 'true-false',\n          options: [\n            { id: 'true', text: 'True', isCorrect: true },\n            { id: 'false', text: 'False', isCorrect: false }\n          ],\n          correctAnswer: 0,\n          explanation: 'Jung indeed founded analytical psychology'\n        }\n      ];\n\n      interface QuestionPreview {\n        id: string;\n        text: string;\n        type: string;\n        optionCount: number;\n        hasExplanation: boolean;\n        index: number;\n      }\n\n      const previews = batchTransform(questions, (q, index): QuestionPreview => ({\n        id: q.id,\n        text: q.question,\n        type: q.type,\n        optionCount: q.options.length,\n        hasExplanation: Boolean(q.explanation),\n        index: index + 1\n      }));\n\n      expect(previews).toHaveLength(2);\n      expect(previews[0].index).toBe(1);\n      expect(previews[0].optionCount).toBe(2);\n      expect(previews[1].type).toBe('true-false');\n    });\n\n    it('should conditionally transform user data', () => {\n      const users: Partial<User>[] = [\n        {\n          id: 'user-1',\n          email: 'admin@example.com',\n          role: UserRole.ADMIN,\n          isActive: true\n        },\n        {\n          id: 'user-2',\n          email: 'inactive@example.com',\n          role: UserRole.STUDENT,\n          isActive: false\n        }\n      ];\n\n      interface UserDisplay {\n        id: string;\n        email: string;\n        status: 'Active' | 'Inactive';\n        canEdit: boolean;\n      }\n\n      const defaultDisplay: UserDisplay = {\n        id: '',\n        email: '',\n        status: 'Inactive',\n        canEdit: false\n      };\n\n      const displays = users.map(user => \n        conditionalTransform(\n          user,\n          (u) => u.isActive === true,\n          (u): UserDisplay => ({\n            id: u.id || '',\n            email: u.email || '',\n            status: 'Active',\n            canEdit: u.role === UserRole.ADMIN\n          }),\n          defaultDisplay\n        )\n      );\n\n      expect(displays[0].status).toBe('Active');\n      expect(displays[0].canEdit).toBe(true);\n      expect(displays[1].status).toBe('Inactive');\n      expect(displays[1].canEdit).toBe(false);\n    });\n  });\n\n  describe('Advanced Generic Constraints', () => {\n    // Constraint: T must have an id property\n    function findById<T extends { id: string }>(items: T[], id: string): T | undefined {\n      return items.find(item => item.id === id);\n    }\n\n    // Constraint: T must have specific properties\n    function sortByCreationDate<T extends { createdAt: Date }>(items: T[]): T[] {\n      return [...items].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n    }\n\n    // Constraint: T must be a Record with string keys\n    function getKeys<T extends Record<string, any>>(obj: T): (keyof T)[] {\n      return Object.keys(obj);\n    }\n\n    // Constraint: T must extend base interface\n    interface Timestamped {\n      createdAt: Date;\n      updatedAt: Date;\n    }\n\n    function updateTimestamp<T extends Timestamped>(item: T): T {\n      return {\n        ...item,\n        updatedAt: new Date()\n      };\n    }\n\n    it('should work with id constraint', () => {\n      const modules: Module[] = [\n        {\n          id: 'module-1',\n          title: 'Module 1',\n          description: 'First module',\n          estimatedTime: 60,\n          difficulty: 'beginner'\n        },\n        {\n          id: 'module-2',\n          title: 'Module 2',\n          description: 'Second module',\n          estimatedTime: 90,\n          difficulty: 'intermediate'\n        }\n      ];\n\n      const permissions: Permission[] = [\n        {\n          id: 'perm-1',\n          resource: ResourceType.MODULE,\n          actions: [Action.READ]\n        },\n        {\n          id: 'perm-2',\n          resource: ResourceType.QUIZ,\n          actions: [Action.CREATE]\n        }\n      ];\n\n      const foundModule = findById(modules, 'module-1');\n      expect(foundModule).toBeDefined();\n      expect(foundModule?.title).toBe('Module 1');\n\n      const foundPermission = findById(permissions, 'perm-2');\n      expect(foundPermission).toBeDefined();\n      expect(foundPermission?.resource).toBe(ResourceType.QUIZ);\n    });\n\n    it('should work with creation date constraint', () => {\n      interface TimestampedModule extends Module {\n        createdAt: Date;\n        updatedAt: Date;\n      }\n\n      const timestampedModules: TimestampedModule[] = [\n        {\n          id: 'module-1',\n          title: 'Module 1',\n          description: 'First module',\n          estimatedTime: 60,\n          difficulty: 'beginner',\n          createdAt: new Date('2024-01-01'),\n          updatedAt: new Date('2024-01-01')\n        },\n        {\n          id: 'module-2',\n          title: 'Module 2',\n          description: 'Second module',\n          estimatedTime: 90,\n          difficulty: 'intermediate',\n          createdAt: new Date('2024-02-01'),\n          updatedAt: new Date('2024-02-01')\n        }\n      ];\n\n      const sorted = sortByCreationDate(timestampedModules);\n      expect(sorted[0].id).toBe('module-2'); // Most recent first\n      expect(sorted[1].id).toBe('module-1');\n    });\n\n    it('should work with Record constraint', () => {\n      const userProgress: UserProgress = {\n        userId: 'user-1',\n        completedModules: ['module-1'],\n        quizScores: {\n          'quiz-1': 85,\n          'quiz-2': 92,\n          'quiz-3': 78\n        },\n        totalTime: 3600,\n        lastAccessed: Date.now(),\n        notes: []\n      };\n\n      const scoreKeys = getKeys(userProgress.quizScores);\n      expect(scoreKeys).toEqual(['quiz-1', 'quiz-2', 'quiz-3']);\n\n      const adaptiveData: Record<string, ConceptMastery> = {\n        'jung-basics': {\n          concept: 'jung-basics',\n          level: 0.8,\n          lastReviewed: new Date(),\n          reviewCount: 5,\n          forgettingCurve: 0.3\n        },\n        'archetypes': {\n          concept: 'archetypes',\n          level: 0.6,\n          lastReviewed: new Date(),\n          reviewCount: 3,\n          forgettingCurve: 0.5\n        }\n      };\n\n      const conceptKeys = getKeys(adaptiveData);\n      expect(conceptKeys).toContain('jung-basics');\n      expect(conceptKeys).toContain('archetypes');\n    });\n\n    it('should work with timestamp update constraint', () => {\n      const timestampedAchievement: Achievement & Timestamped = {\n        id: 'achieve-1',\n        title: 'First Achievement',\n        description: 'Your first achievement',\n        icon: '🏆',\n        category: 'progress',\n        points: 100,\n        unlockedAt: new Date(),\n        rarity: 'common',\n        requirements: [],\n        createdAt: new Date('2024-01-01'),\n        updatedAt: new Date('2024-01-01')\n      };\n\n      const originalUpdatedAt = timestampedAchievement.updatedAt.getTime();\n      \n      // Wait a tiny bit to ensure different timestamp\n      await new Promise(resolve => setTimeout(resolve, 1));\n      \n      const updated = updateTimestamp(timestampedAchievement);\n      expect(updated.updatedAt.getTime()).toBeGreaterThan(originalUpdatedAt);\n      expect(updated.id).toBe('achieve-1');\n    });\n  });\n\n  describe('Conditional Types and Mapped Types', () => {\n    // Conditional type: Extract keys of specific type\n    type KeysOfType<T, U> = {\n      [K in keyof T]: T[K] extends U ? K : never;\n    }[keyof T];\n\n    // Mapped type: Make specific properties optional\n    type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n    // Mapped type: Extract non-null properties\n    type NonNullable<T> = {\n      [K in keyof T]: T[K] extends null | undefined ? never : T[K];\n    };\n\n    it('should extract string keys from Module', () => {\n      type ModuleStringKeys = KeysOfType<Module, string>;\n      \n      // These should be valid string keys\n      const validKeys: ModuleStringKeys[] = ['id', 'title', 'description'];\n      expect(validKeys).toContain('id');\n      expect(validKeys).toContain('title');\n      expect(validKeys).toContain('description');\n    });\n\n    it('should create partially optional types', () => {\n      type PartialModule = PartialBy<Module, 'category' | 'tags' | 'version'>;\n      \n      const partialModule: PartialModule = {\n        id: 'test',\n        title: 'Test Module',\n        description: 'Test description',\n        estimatedTime: 60,\n        difficulty: 'beginner'\n        // category, tags, and version are now optional\n      };\n\n      expect(partialModule.id).toBe('test');\n      expect(partialModule.category).toBeUndefined();\n    });\n\n    it('should handle union type discrimination', () => {\n      type ProcessingState = \n        | { status: 'idle' }\n        | { status: 'loading'; progress: number }\n        | { status: 'success'; data: any }\n        | { status: 'error'; error: string };\n\n      function handleState(state: ProcessingState): string {\n        switch (state.status) {\n          case 'idle':\n            return 'Ready to start';\n          case 'loading':\n            return `Loading: ${state.progress}%`;\n          case 'success':\n            return `Success: ${JSON.stringify(state.data)}`;\n          case 'error':\n            return `Error: ${state.error}`;\n          default:\n            const _exhaustive: never = state;\n            return 'Unknown state';\n        }\n      }\n\n      expect(handleState({ status: 'idle' })).toBe('Ready to start');\n      expect(handleState({ status: 'loading', progress: 50 })).toBe('Loading: 50%');\n      expect(handleState({ status: 'success', data: { result: 'ok' } }))\n        .toContain('ok');\n      expect(handleState({ status: 'error', error: 'Network failed' }))\n        .toContain('Network failed');\n    });\n\n    it('should work with recursive types', () => {\n      interface TreeNode<T> {\n        value: T;\n        children: TreeNode<T>[];\n      }\n\n      function traverseTree<T>(node: TreeNode<T>, visitor: (value: T) => void): void {\n        visitor(node.value);\n        node.children.forEach(child => traverseTree(child, visitor));\n      }\n\n      function countNodes<T>(node: TreeNode<T>): number {\n        return 1 + node.children.reduce((count, child) => count + countNodes(child), 0);\n      }\n\n      const moduleTree: TreeNode<string> = {\n        value: 'Psychology',\n        children: [\n          {\n            value: 'Analytical Psychology',\n            children: [\n              { value: 'Jung\\'s Theory', children: [] },\n              { value: 'Archetypes', children: [] }\n            ]\n          },\n          {\n            value: 'Cognitive Psychology',\n            children: []\n          }\n        ]\n      };\n\n      const values: string[] = [];\n      traverseTree(moduleTree, value => values.push(value));\n      \n      expect(values).toContain('Psychology');\n      expect(values).toContain('Jung\\'s Theory');\n      expect(values).toHaveLength(5);\n      \n      const nodeCount = countNodes(moduleTree);\n      expect(nodeCount).toBe(5);\n    });\n  });\n});