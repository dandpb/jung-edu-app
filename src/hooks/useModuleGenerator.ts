import { useState, useCallback } from 'react';
import { Module, Section, Question, Quiz } from '../types';
import { GenerationConfig } from '../components/admin/AIModuleGenerator';
import { GenerationStep } from '../components/admin/GenerationProgress';
import { ModuleGenerationOrchestrator, GenerationOptions, GenerationProgress } from '../services/llm/orchestrator';

// Fun√ß√£o auxiliar para extrair ID do v√≠deo do YouTube da URL
const extractYouTubeId = (url: string): string | null => {
  const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
  const match = url.match(regex);
  return match ? match[1] : null;
};

interface UseModuleGeneratorReturn {
  isGenerating: boolean;
  generatedModule: Module | null;
  generationSteps: GenerationStep[];
  currentStep: number;
  error: string | null;
  generateModule: (config: GenerationConfig) => Promise<void>;
  regenerateSection: (sectionId: string) => Promise<void>;
  updateGeneratedModule: (module: Module) => void;
  reset: () => void;
}

// Fun√ß√£o real de gera√ß√£o de IA usando orquestrador LLM
const generateAIModule = async (
  config: GenerationConfig,
  onProgress?: (progress: GenerationProgress) => void
): Promise<Module> => {
  const orchestrator = new ModuleGenerationOrchestrator();
  
  // Configura listener de progresso se fornecido
  if (onProgress) {
    orchestrator.on('progress', onProgress);
  }
  
  // Converte configura√ß√£o da UI para op√ß√µes do orquestrador
  const generationOptions: GenerationOptions = {
    topic: config.subject,
    objectives: [
      `Compreender os conceitos fundamentais de ${config.subject}`,
      `Aplicar os princ√≠pios de ${config.subject} em contextos pr√°ticos`,
      `Analisar o papel de ${config.subject} na psicologia junguiana`
    ],
    targetAudience: config.targetAudience || 'estudantes de psicologia',
    duration: config.estimatedTime,
    difficulty: config.difficulty,
    includeVideos: config.includeVideos,
    includeBibliography: config.includeBibliography,
    includeMindMap: false, // Mapas mentais s√£o tratados separadamente
    quizQuestions: config.includeQuiz ? 5 : 0,
    videoCount: config.includeVideos ? 3 : 0,
    bibliographyCount: config.includeBibliography ? 8 : 0,
    useRealServices: true
  };
  
  try {
    // Verifica se o provedor est√° dispon√≠vel antes de iniciar a gera√ß√£o
    const isProviderAvailable = await orchestrator.checkProviderAvailability();
    console.log('Verifica√ß√£o de disponibilidade do provedor:', isProviderAvailable);
    
    if (!isProviderAvailable) {
      throw new Error('O provedor LLM n√£o est√° dispon√≠vel. Verifique a configura√ß√£o da sua chave de API.');
    }
    
    const result = await orchestrator.generateModule(generationOptions);
    
    // Converte resultado do orquestrador para formato Module esperado
    const module: Module = {
      ...result.module,
      icon: 'üß†', // √çcone padr√£o
      content: {
        ...result.content,
        videos: (result.videos || []).map(video => ({
          id: video.id,
          title: video.title,
          youtubeId: video.youtubeId || extractYouTubeId((video as any).url || '') || 'dQw4w9WgXcQ', // Fallback para v√≠deo padr√£o
          description: video.description,
          duration: typeof (video as any).duration === 'object' ? (video as any).duration.minutes : video.duration || 15
        })),
        bibliography: result.bibliography || [],
        films: [], // N√£o gerado atualmente
        quiz: result.quiz ? (() => {
          console.log('üéØ Debug: Quiz received from orchestrator:', {
            hasQuiz: !!result.quiz,
            questionCount: result.quiz?.questions?.length || 0,
            questions: result.quiz?.questions?.map((q: any) => ({
              id: q.id,
              hasQuestion: !!q.question,
              hasOptions: !!q.options,
              optionsCount: q.options?.length || 0,
              type: q.type
            }))
          });
          return {
          id: result.quiz.id,
          title: result.quiz.title,
          questions: result.quiz.questions
            .map((q: any, index: number) => {
              // Ensure we have proper question format
              const questionData = {
                id: q.id || `q-${index + 1}`,
                question: q.question || `Quest√£o ${index + 1}`,
                type: q.type || 'multiple-choice',
                correctAnswer: q.correctAnswer || 0,
                explanation: q.explanation || 'Nenhuma explica√ß√£o fornecida'
              };

              // Handle options - ensure we always have at least 4 options
              if (q.options && Array.isArray(q.options) && q.options.length >= 2) {
                return {
                  ...questionData,
                  options: q.options.map((opt: any, optIndex: number) => ({
                    id: `${questionData.id}-opt-${optIndex + 1}`,
                    text: typeof opt === 'string' ? opt : opt.text || `Op√ß√£o ${optIndex + 1}`,
                    isCorrect: optIndex === questionData.correctAnswer
                  }))
                };
              } else {
                // Create fallback options if none exist or malformed
                const fallbackOptions = [
                  'Conceito fundamental da psicologia junguiana',
                  'Aplica√ß√£o espec√≠fica da teoria anal√≠tica',
                  'Aspecto secund√°rio do desenvolvimento pessoal',
                  'Elemento n√£o relacionado √† individua√ß√£o'
                ];
                
                return {
                  ...questionData,
                  options: fallbackOptions.map((opt, optIndex) => ({
                    id: `${questionData.id}-opt-${optIndex + 1}`,
                    text: opt,
                    isCorrect: optIndex === 0 // First option is correct by default
                  }))
                };
              }
            })
            .filter(q => q && q.question && q.options && q.options.length >= 2) // Only filter out completely invalid questions
          };
        })() : undefined
      }
    };
    
    console.log('üéØ Debug: Final module quiz:', {
      hasQuiz: !!module.content.quiz,
      finalQuestionCount: module.content.quiz?.questions?.length || 0
    });
    
    return module;
  } catch (error) {
    console.error('Falha na gera√ß√£o do m√≥dulo:', error);
    throw new Error(`Falha ao gerar m√≥dulo: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);
  }
};

export const useModuleGenerator = (): UseModuleGeneratorReturn => {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedModule, setGeneratedModule] = useState<Module | null>(null);
  const [generationSteps, setGenerationSteps] = useState<GenerationStep[]>([]);
  const [currentStep, setCurrentStep] = useState(0);
  const [error, setError] = useState<string | null>(null);
  
  // Adiciona m√©todo para definir diretamente o m√≥dulo gerado (para edi√ß√µes)
  const setModule = useCallback((module: Module) => {
    setGeneratedModule(module);
  }, []);

  const generateModule = useCallback(async (config: GenerationConfig) => {
    setIsGenerating(true);
    setError(null);
    
    // Define etapas de gera√ß√£o que mapeiam para os est√°gios do orquestrador
    const steps: GenerationStep[] = [
      {
        id: 'initializing',
        label: 'Inicializando processo de gera√ß√£o',
        status: 'pending'
      },
      {
        id: 'content',
        label: 'Gerando conte√∫do educacional',
        status: 'pending'
      },
      ...(config.includeQuiz ? [{
        id: 'quiz',
        label: 'Criando quest√µes de avalia√ß√£o',
        status: 'pending' as const
      }] : []),
      ...(config.includeVideos ? [{
        id: 'videos',
        label: 'Buscando recursos de v√≠deo',
        status: 'pending' as const
      }] : []),
      ...(config.includeBibliography ? [{
        id: 'bibliography',
        label: 'Compilando bibliografia',
        status: 'pending' as const
      }] : []),
      {
        id: 'finalizing',
        label: 'Finalizando m√≥dulo',
        status: 'pending'
      }
    ];
    
    setGenerationSteps(steps);
    setCurrentStep(0);
    
    try {
      // Gera o m√≥dulo com chamadas reais de LLM
      const module = await generateAIModule(config, (progress: GenerationProgress) => {
        // Atualiza etapas baseado no progresso do orquestrador
        const stageToStepMap: Record<string, string> = {
          'initializing': 'initializing',
          'content': 'content',
          'quiz': 'quiz',
          'videos': 'videos',
          'bibliography': 'bibliography',
          'finalizing': 'finalizing',
          'complete': 'finalizing'
        };
        
        const activeStepId = stageToStepMap[progress.stage] || 'content';
        const stepIndex = steps.findIndex(step => step.id === activeStepId);
        
        if (stepIndex >= 0) {
          setCurrentStep(stepIndex);
          setGenerationSteps(prev => prev.map((step, idx) => ({
            ...step,
            status: idx < stepIndex ? 'completed' : 
                   idx === stepIndex ? 'in-progress' : 'pending',
            message: idx === stepIndex ? progress.message : step.message
          })));
        }
      });
      
      // Marca todas as etapas como conclu√≠das
      setGenerationSteps(prev => prev.map(step => ({
        ...step,
        status: 'completed'
      })));
      
      setGeneratedModule(module);
    } catch (err) {
      console.error('Erro na gera√ß√£o do m√≥dulo:', err);
      setError(err instanceof Error ? err.message : 'Falha ao gerar m√≥dulo');
      setGenerationSteps(prev => prev.map((step, idx) => ({
        ...step,
        status: idx === currentStep ? 'error' : step.status,
        message: idx === currentStep ? 'Falha na gera√ß√£o' : step.message
      })));
    } finally {
      setIsGenerating(false);
    }
  }, [currentStep]);

  const regenerateSection = useCallback(async (sectionId: string) => {
    if (!generatedModule) return;
    
    // Simula regenera√ß√£o de uma se√ß√£o
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const updatedSections = generatedModule.content.sections.map(section => {
      if (section.id === sectionId) {
        return {
          ...section,
          content: `[Regenerado] ${section.content}`,
          keyTerms: [
            ...section.keyTerms || [],
            {
              term: 'Novo Conceito',
              definition: 'Um aspecto rec√©m-descoberto da regenera√ß√£o'
            }
          ]
        };
      }
      return section;
    });
    
    setGeneratedModule({
      ...generatedModule,
      content: {
        ...generatedModule.content,
        sections: updatedSections
      }
    });
  }, [generatedModule]);

  const reset = useCallback(() => {
    setIsGenerating(false);
    setGeneratedModule(null);
    setGenerationSteps([]);
    setCurrentStep(0);
    setError(null);
  }, []);

  return {
    isGenerating,
    generatedModule,
    generationSteps,
    currentStep,
    error,
    generateModule,
    regenerateSection,
    updateGeneratedModule: setModule,
    reset
  };
};